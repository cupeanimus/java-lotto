# 로또
## 진행 방법
* 로또 요구사항을 파악한다.
* 요구사항에 대한 구현을 완료한 후 자신의 github 아이디에 해당하는 브랜치에 Pull Request(이하 PR)를 통해 코드 리뷰 요청을 한다.
* 코드 리뷰 피드백에 대한 개선 작업을 하고 다시 PUSH한다.
* 모든 피드백을 완료하면 다음 단계를 도전하고 앞의 과정을 반복한다.

## 온라인 코드 리뷰 과정
* [텍스트와 이미지로 살펴보는 온라인 코드 리뷰 과정](https://github.com/next-step/nextstep-docs/tree/master/codereview)


## 3단계 - 로또(자동)
* 구입 금액에 해당하는 로또 구매
* 로또 번호 자동 생성
* 당첨 번호 생성(자동 생성 활용)
* 당첨 통계
* UI로직 구현

### 피드백
##### 1차
* LottoGame과 view 의존관계 분리
* 객체 내 변수 삭제
* LottoGame에서 내부 변수를 제어하기 위해 생성자를 통해 입력된 객체 대신 인터페이스를 선언하여 주입하고 편리하게 컨트롤 한다.
    - 내부 변수가 필요없는 객체이기 때문에 조언해주신 방향은 좋은 정보로 소중히 메모하였고 위와 같은 상황이 생길 때 이 방법으로 작업해보겠습니다. 

이 과제를 진행 할 때 그린 설계는 LottoGame은 서비스와 같고 이 내부에서 플로우가 흘러가는 것이었다. 
때문에 화면 부분이 분리되어 보여지기 위해 서로 의존관계가 형성되었고, 내부 변수를 제어하기 위해 생성자로 입력받게 되었다.
다시 돌아보면 로또 게임에서 주도해야한다는 잘못된 생각으로 전체 흐름이 망가져 객체 지향이라 할 수 없는 설계인 것이다.
따라서, 의존관계를 모두 없애고, 서비스는 플레이 메인 클래스에 일임, 
나머지는 각 해당 객체에 해당하는 값을 입력, 반환하는 순수 객체로의 역할만 수행하도록 수정하려 하였다.

##### 2차
* main 클래스 실행은 흐름은 로직으로 LottoGame 객체안에서 실행하도록 한다(테스트 용이)
* 상수값과 같이 불변값엔 final을 적극 사용한다
* List의 경우에는 final이 된다 하더라도 추가 삭제 될 수 있어서 필요시  Collections.unmodifiableList(List) 로 한번 더 감싸서 불변성을 유지한다
 -> 해당 부분은 셔플이 적용되는 부분으로 하지 않는다.

## 4단계 - 로또(자동)

* 보너스 볼 입력 추가 
* 당첨목록에 2등 추가
* 2등 당첨 적용
* 당첨 통계 수정 
* 리팩토링 

## 5단계 - 로또(수동)

* 리뷰 반영
* 로또 피드백 강의 학습
* 1차 리팩토링
* 수동으로 로또번호 입력
* 로또 결과 확인 
* 리팩토링
    * 모든 원시값 문자열 포장
    * 축약 금지
    * 예외처리를 통해 에러 발생 않도록
    * 피드백 강의 반영

### 피드백
*[X] 생성자 접근제한자 수정
*[X] collection 불변성 확보
*[X] inputView 인터페이스로 분리하여 테스트시 전체 로직 실행 확인
*[X] 중간 사용되는 int형 구매가능 개수값 포장
*[X] totalPrize 내 변수를 불변객체로 수정 -> 이 과정에서 lottoGame에서 당첨결과 처리하는 작업이 winningResult에 위임되었음